


 _newfile_ :Z:\DESKTOP\CODING\seize/./seize.py




import pyglet,json
import pyglet.gl as gl
from pyglet.window import key
from src.utils import *
from src import graphic as g
from src.dic import *
import src.colors as c

FULLSCREEN = False

CURRENT_PATH = os.path.dirname(os.path.abspath(__file__)) # fopatouché
if ' ' in CURRENT_PATH:
    print('Le chemin d\'acces contient un espace. Le programme va BUGUER SA MERE.')
    print('Changez le programme de place pour un path sans espace svp.')


"""###########################################################"""

class App():


    ### INIT FUNCTIONS

    def __init__(self):

        initial_size = 1000,800
        self.window = pyglet.window.Window(*initial_size,file_drops=True,resizable=True)
        self.window.push_handlers(self)

        self.icon = pyglet.resource.image("icon.ico")
        self.window.set_icon(self.icon)


        ## paths
        self.path = CURRENT_PATH
        self.config_path = '\\config\\'
        self.saves_path = '\\saves\\'


        ## size window

        self.style = 'normal'
        self.tmp_style = 'maximize'

        self.normal_size = initial_size
        self.window.set_minimum_size(275,200)


        ## screens
        display = pyglet.canvas.get_display()
        self.screens = display.get_screens()
        self.maximized_sizes = {}
        for scr in self.screens:
            self.maximized_sizes[scr] = 0,0

        self.S = self.window.get_size()

    def init(self):

        ### PART I : several thgs

        self.mode = 'showing'

        self.modes = ['showing','editing']

        """
        modes:
        -showing
        -editing
        """

        ## pending tasks
        #self.pending_tasks = []


        ## keys
        self.keys = key.KeyStateHandler()
        self.window.push_handlers(self.keys)

        self.keys_pressed = {} # example {key.A:[145124 sec,"modif"]}

        ## mouse
        self.R,self.L = False,False
        self.M = [0,0]


        ### PART II : sprites etc

        ## dics, batch / group
        self.textures = {}
        self.sprites = {}

        self.batch = pyglet.graphics.Batch()

        self.group_10 = pyglet.graphics.OrderedGroup(-10)
        self.group0 = pyglet.graphics.OrderedGroup(0)
        self.group1 = pyglet.graphics.OrderedGroup(1)
        self.group5 = pyglet.graphics.OrderedGroup(5)
        self.group10 = pyglet.graphics.OrderedGroup(10)

        ## managers
        #self.tman = g.TextureManager()
        #self.sman = g.SpriteManager(self.batch)

        ## sprites


        ### PART III : labels / cursor => Seizes

        ## seizes
        self.sz_id = []
        self.seize = {}
        self.sz = 0

        self.anchor = (self.S[0]*0.5,self.S[1]*0.5)
        self.initial_pos = (-self.S[0]*0.25,self.S[1]*0.25)


        ### PART IV : buttons, ..

        self.buttons = {}
        self.buttons['save'] = g.Button(box(self.S[0]-100,self.S[1] -150,30,30),self.save_file,c.oldlace,c.blue,self.batch,group=self.group5)
        self.buttons['thg'] = g.Button(box(self.S[0]-100,self.S[1] -150,30,30),self.get_out,c.deepskyblue,c.blue,self.batch,group=self.group5)
        self.butbar = {}
        self.butbar['main'] = g.ButtonBar((0,0.8),self.S,[self.buttons['save'],self.buttons['thg']],align='right',batch=self.batch,group=self.group1,groupbutt=self.group5)

        self.open_config()
        #self.addSeize('megaseize',True)

        #self.seize[self.sz_id[self.sz]] = g.Seize('megaseize',group=self.group0,batch=self.batch,x=-self.S[0]*0.25,y=self.S[1]*0.25)

        ## cursor
        self.cursor = g.Cursor(group=self.group10,batch=self.batch)

        ### PART V : final launch

        ## launching the machine u know (launching gameloop)
        self.playing = True
        self.draww = True
        self.nb = 0
        pyglet.clock.schedule_interval(self.gameloop,0.0000000000001)

        if FULLSCREEN:
            self.change_size('borderless')

        pyglet.app.run()


    ### ONCE FUNCTIONS

    def addSeize(self,name='jeanluc',main=False,id=None,initial=''):

        if id == None:
            id = get_id('sz')
        self.sz_id.append(id)
        x,y = self.initial_pos
        self.seize[id] = g.Seize(name,id,group=self.group0,batch=self.batch,x=x,y=y,initial=initial)
        if main:
            self.sz = len(self.seize) - 1

    def get_current_screen(self):

        x,y = self.window.get_location()
        for i in range(len(self.screens)):
            scr = self.screens[i]
            if (x >= scr.x and x <= scr.x + scr.width) and (y >= scr.y and y <= scr.y + scr.height):
                return scr
        return self.screens[0]

    def load_maximized_sizes(self):

        ## return the potential sizes of maximized window for each screen

        self.maximized_sizes = {}

        for screen in self.screens:

            windo = pyglet.window.Window(resizable=True,screen=screen,visible=False)
            #self.window.set_location(screen.x+1,screen.y+1)
            windo.maximize()
            #os.system('pause')
            self.maximized_sizes[screen] = windo.get_size()
            windo.close()

    def change_mode(self,mode='editing'):

        if mode == 'editing':
            for id in self.seize:
                if id != self.sz_id[self.sz]:
                    self.seize[id].hide()
                else:
                    self.seize[id].hide(False)
        elif mode == 'showing':
            for id in self.seize:
                self.seize[id].hide(False)
        self.mode = mode

    def roll(self):
        self.sz += 1
        if self.sz >= len(self.sz_id):
            self.sz = 0
        if self.mode == 'editing':
            self.change_mode('editing')
        if len(self.sz_id) > 0:
            print('--'+self.seize[self.sz_id[self.sz]].name+' main--')

    def change_size(self,style='maximize'):

        if self.style != style:
            self.tmp_style = self.style

            if self.style == 'borderless':

                newwindow = pyglet.window.Window(file_drops=True,resizable=True)
                newwindow.push_handlers(self)
                newwindow.push_handlers(self.keys)
                self.window.close()
                self.window = newwindow
                self.window.set_icon(self.icon)

                ## size window
                self.window.set_minimum_size(275,200)
                self.style = style

                self.window.set_size(*self.normal_size)

                if style == 'maximize':
                    self.window.maximize()

            elif style == 'borderless':

                if self.style == 'normal':
                    self.normal_size = self.window.get_size()

                self.style = style


                old_pos = self.window.get_location()

                newwindow = pyglet.window.Window(file_drops=True,resizable=True,style=pyglet.window.Window.WINDOW_STYLE_BORDERLESS)
                newwindow.push_handlers(self)
                newwindow.push_handlers(self.keys)
                self.window.close()
                self.window = newwindow
                self.window.set_location(*old_pos)
                self.window.set_minimum_size(275,200)
                self.window.set_icon(self.icon)


                self.window.maximize()

            elif style == 'maximize' and self.style == 'normal':

                self.style = style
                self.window.maximize()

            elif style == 'normal' and self.style == 'maximize':
                self.window.set_size(*self.normal_size)
                self.style = style

    def get_out(self):
        self.playing = False


    #opening/saving
    def open_file(self,file,main=True):

        text = ''

        if self.saves_path[1:-1] not in os.listdir(self.path):
            os.makedirs(self.path + self.saves_path)

        if file +'.txt' in os.listdir(self.path + self.saves_path):
            with open(self.path + self.saves_path + file +'.txt','r') as f:
                text = f.read()
            if text[-1] == '\n':
                text = text[:-1]

        self.addSeize(file,main,initial=text)

        print(file + ' opened')

    def close_file(self,id=None):

        if id == None: # on ferme le fichier en cours
            id = self.sz_id[self.sz]
        self.save_file(id)
        self.seize[id].delete()
        del self.seize[id]
        self.sz_id.remove(id)
        self.roll()

    def save_file(self,id=None):

        #print(file + ' saved')
        if id == None: # on sauvegarde le fichier en cours
            id = self.sz_id[self.sz]

        file=self.seize[id].name

        #print('')
        if self.saves_path[1:-1] not in os.listdir(self.path):
            os.makedirs(self.path+self.saves_path)

        with open(self.path+self.saves_path+file+'.txt','w') as f:
            f.write(self.seize[id].get_text())

        print(file + ' saved')

    def open_config(self):

        print('\n----------\n')

        if self.config_path[1:-1] not in os.listdir(self.path):
            os.makedirs(self.path + self.config_path)

        #self.configg= []

        if 'config' in os.listdir(self.path + self.config_path):

            print('opening config file')

            with open(self.path + self.config_path +'config','r') as f:
                try:
                    self.configg= json.load(f)
                except:
                    self.configg = []
        else:
            print('confing file lost in the nean...')
            self.configg = []

        if self.configg != []:
            for file in self.configg:
                name,main = file
                if name+'.txt' in os.listdir(self.path+self.saves_path):
                    self.open_file(name,main)
        else:
            self.open_file('megaseize')

        print('\n----------\n')

    def save_config(self):

        if self.config_path[1:-1] not in os.listdir(self.path):
            os.makedirs(self.path + self.config_path)

        self.update_config()
        for id in self.seize:
            self.save_file(id)

        with open(self.path + self.config_path +'config','w') as f:
            json.dump(self.configg,f)

        print('config file saved')
        print('\n----------\n')

    def update_config(self):

        if self.config_path[1:-1] not in os.listdir(self.path):
            os.makedirs(self.path + self.config_path)

        self.configg= []

        for id in self.seize:
            tab = [self.seize[id].name]
            if self.sz_id[self.sz] == id:
                tab.append(True)
            else:
                tab.append(False)
            self.configg.append(tab)


    ### PYGLET EVENTS

    def on_key_press(self,symbol,modifiers):

        ## controls globaux

        if symbol == key.ESCAPE:
            self.get_out()
            #self.playing = False

        elif symbol == key.F11:

            if self.style == 'borderless':
                self.change_size(self.tmp_style)
            else:
                self.change_size('borderless')

        ## controls avec et sans modifieurs

        if self.keys[key.LCTRL]:

            if symbol == key.K:
                yeye,mode = 0,''
                for i in range(len(self.modes)):
                    if self.modes[i] == self.mode:
                        yeye = i
                if yeye +1 == len(self.modes):
                    mode = self.modes[0]
                else:
                    mode = self.modes[yeye+1]
                self.change_mode(mode)

            elif symbol == key.F:
                if self.label_fps.color[3] == 0:
                    self.label_fps.color = [*self.label_fps.color[:3],255]
                elif self.label_fps.color[3] == 255:
                    self.label_fps.color = [*self.label_fps.color[:3],0]

            elif symbol == key.N:
                self.open_file(input('new file name :'))

            elif symbol == key.TAB:
                self.roll()

            elif symbol == key.S:
                self.save_file()

            elif symbol == key.W:
                self.close_file()

        else:

            if self.keys[key.LSHIFT]:

                if symbol in up_dic:
                    self.seize[self.sz_id[self.sz]].change(up_dic[symbol])
                    self.keys_pressed[symbol] = [time.time(),"up"]

            else:
                if symbol in low_dic:
                    self.seize[self.sz_id[self.sz]].change(low_dic[symbol])
                    self.keys_pressed[symbol] = [time.time(),"low"]

            if symbol in motion_dic:
                self.seize[self.sz_id[self.sz]].motion(motion_dic[symbol])
                self.keys_pressed[symbol] = [time.time(),"motion"]
            elif symbol in modif_dic:

                self.seize[self.sz_id[self.sz]].modif(modif_dic[symbol])
                self.keys_pressed[symbol] = [time.time(),"modif"]

    def on_key_release(self,symbol,modifiers):

        if symbol in self.keys_pressed:
            del self.keys_pressed[symbol]

    def on_mouse_motion(self,x,y,dx,dy):

        self.M = [x,y]
        self.mouse_speed = module(dx,dy)


        for bar in self.butbar:
            if self.butbar[bar].visible :
                self.butbar[bar].check_mouse(x,y)

    def on_mouse_drag(self,x, y, dx, dy, buttons, modifiers):

        self.M = [x,y]
        self.mouse_speed = module(dx,dy)

        if self.mode == 'showing':
            hovers = []
            for bar in self.butbar:
                if self.butbar[bar].visible :
                    hovers = self.butbar[bar].get_hovers()
            if hovers == [] :
                self.seize[self.sz_id[self.sz]].movedx((dx,dy))
        else:
            for bar in self.butbar:
                if self.butbar[bar].visible :
                    self.butbar[bar].check_mouse(x,y)

    def on_mouse_press(self,x, y, button, modifiers):

        if button == pyglet.window.mouse.LEFT :
            for bar in self.butbar:
                if self.butbar[bar].visible :
                    self.butbar[bar].check_pressed()

    def on_mouse_release(self,x, y, button, modifiers):

        if button == pyglet.window.mouse.LEFT :
            for bar in self.butbar:
                if self.butbar[bar].visible :
                    self.butbar[bar].check_released()
                    self.butbar[bar].check_mouse(x,y)

    def on_close(self):

        self.save_config()

        print('\n\nNumber of lines :',compt(self.path))
        save_code(self.path)

    def on_resize(self,width,height):

        #print('ahhhh on me resuize',width,height,self.maximized_sizes[self.get_current_screen()])

        max_size = self.maximized_sizes[self.get_current_screen()]
        if (width,height) == self.maximized_sizes[self.get_current_screen()] and self.style != 'maximize' : #si la taille correspond à la taille de maximized
            #print('ouee')
            self.tmp_style = self.style
            self.style = 'maximize'

        elif width < max_size[0] and height < max_size[1] and self.style != 'normal' : #si la taille correspond à la taille de maximized
            self.tmp_style = self.style
            self.style = 'normal'
            self.normal_size = width,height

        elif self.style == 'normal':
            self.normal_size = width,height

    ### EVENTS

    def events(self):

        delay_pressed = 0.4
        current_time = time.time()

        for key in self.keys_pressed:
            if current_time - self.keys_pressed[key][0] > delay_pressed:
                if self.keys_pressed[key][1] == "up":
                    self.seize[self.sz_id[self.sz]].change(up_dic[key])
                elif self.keys_pressed[key][1] == "low":
                    self.seize[self.sz_id[self.sz]].change(low_dic[key])
                elif self.keys_pressed[key][1] == "motion":
                    self.seize[self.sz_id[self.sz]].motion(motion_dic[key])
                elif self.keys_pressed[key][1] == "modif":
                    self.seize[self.sz_id[self.sz]].modif(modif_dic[key])


        # label fps
        self.label_fps.text = 'FPS : '+str(int(pyglet.clock.get_fps()))
        self.label_fps.x,self.label_fps.y = 20,self.S[1] -20

        # label mode
        self.label_mode.text = self.mode
        self.label_mode.x,self.label_mode.y = self.S[0]-10,self.S[1] -10

    ### GAMELOOP

    def draw(self):

        self.batch.draw()

    def refresh(self):

        if self.window.get_size() != self.S:
            for id in self.seize:
                self.seize[id].adapt_xy(self.S,self.window.get_size())
            self.S = self.window.get_size()

        self.anchor = self.S[0]*0.5,self.S[1]*0.5

        ## buttons
        self.butbar["main"].update(self.S)

        ### refresh seize
        for id in self.seize:
            self.seize[id].refresh(self.anchor)

        self.cursor.refresh(self.seize[self.sz_id[self.sz]],self.S,self.anchor)

        #print(self.style,self.normal_size)


        ### PENDING TASKS

        """while len(self.pending_tasks) != 0 :
            if self.pending_tasks[0] != None:
                self.pending_tasks[0]()
            self.pending_tasks[1:]"""

    def gameloop(self,dt):

        pyglet.clock.tick()

        if self.nb == 0:

            self.label_fps = pyglet.text.Label('',font_name='arial',font_size=32,group=self.group10, \
                            batch=self.batch,color=(255,255,255,255),anchor_y='top')
            self.label_mode = pyglet.text.Label('',font_name='arial',font_size=8,group=self.group10, \
                            batch=self.batch,color=(255,255,255,255),anchor_y='top',anchor_x='right')

            self.load_maximized_sizes()
            print('screens initialised ->',self.maximized_sizes)

        self.nb+=1


        #print(self.playing)

        if self.playing:

            ### EVENTS
            self.events()

            gl.glClearColor(1/35,1/35,1/35,1)
            ### CLEAR
            self.window.clear()

            ### REFRESH
            self.refresh()

            ### DRAW
            self.draw()
            #print("aaaaaaah")


        else:

            self.on_close()
            self.window.close()



"""###########################################################"""

def main():

    app = App()
    app.init()

if __name__ == '__main__':
    main()



 _newfile_ :Z:\DESKTOP\CODING\seize/src/colors.py



### colors

air = (0,0,0,0)
aliceblue = (240, 248, 255,255)
antiquewhite = (250, 235, 215,255)
aqua = (0, 255, 255,255)
aquamarine = (127, 255, 212,255)
azure = (240, 255, 255,255)
beige = (245, 245, 220,255)
bisque = (255, 228, 196,255)
black = (0, 0, 0,255)
blanchedalmond = (255, 235, 205,255)
blue = (0, 0, 255,255)
blueviolet = (138, 43, 226,255)
brown = (165, 42, 42,255)
burlywood = (222, 184, 135,255)
cadetblue = (95, 158, 160,255)
chartreuse = (127, 255, 0,255)
chocolate = (210, 105, 30,255)
coral = (255, 127, 80,255)
cornflowerblue = (100, 149, 237,255)
cornsilk = (255, 248, 220,255)
crimson = (220, 20, 60,255)
cyan = (0, 255, 255,255)
darkblue = (0, 0, 139,255)
darkcyan = (0, 139, 139,255)
darkgoldenrod = (184, 134, 11,255)
darkgray = (169, 169, 169,255)
darkgrey = (169, 169, 169,255)
darkgreen = (0, 100, 0,255)
darkkhaki = (189, 183, 107,255)
darkmagenta = (139, 0, 139,255)
darkolivegreen = (85, 107, 47,255)
darkorange = (255, 140, 0,255)
darkorchid = (153, 50, 204,255)
darkred = (139, 0, 0,255)
darksalmon = (233, 150, 122,255)
darkseagreen = (143, 188, 143,255)
darkslateblue = (72, 61, 139,255)
darkslategray = (47, 79, 79,255)
darkslategrey = (47, 79, 79,255)
darkturquoise = (0, 206, 209,255)
darkviolet = (148, 0, 211,255)
deeppink = (255, 20, 147,255)
deepskyblue = (0, 191, 255,255)
dimgray = (105, 105, 105,255)
dimgrey = (105, 105, 105,255)
dodgerblue = (30, 144, 255,255)
firebrick = (178, 34, 34,255)
floralwhite = (255, 250, 240,255)
forestgreen = (34, 139, 34,255)
fuchsia = (255, 0, 255,255)
gainsboro = (220, 220, 220,255)
ghostwhite = (248, 248, 255,255)
gold = (255, 215, 0,255)
goldenrod = (218, 165, 32,255)
gray = (128, 128, 128,255)
grey = (128, 128, 128,255)
green = (0, 128, 0,255)
greenyellow = (173, 255, 47,255)
honeydew = (240, 255, 240,255)
hotpink = (255, 105, 180,255)
indianred = (205, 92, 92,255)
indigo = (75, 0, 130,255)
ivory = (255, 255, 240,255)
khaki = (240, 230, 140,255)
lavender = (230, 230, 250,255)
lavenderblush = (255, 240, 245,255)
lawngreen = (124, 252, 0,255)
lemonchiffon = (255, 250, 205,255)
lightblue = (173, 216, 230,255)
lightcoral = (240, 128, 128,255)
lightcyan = (224, 255, 255,255)
lightgoldenrodyellow = (250, 250, 210,255)
lightgray = (211, 211, 211,255)
lightgrey = (211, 211, 211,255)
lightgreen = (144, 238, 144,255)
lightpink = (255, 182, 193,255)
lightsalmon = (255, 160, 122,255)
lightseagreen = (32, 178, 170,255)
lightskyblue = (135, 206, 250,255)
lightslategray = (119, 136, 153,255)
lightslategrey = (119, 136, 153,255)
lightsteelblue = (176, 196, 222,255)
lightyellow = (255, 255, 224,255)
lime = (0, 255, 0,255)
limegreen = (50, 205, 50,255)
linen = (250, 240, 230,255)
magenta = (255, 0, 255,255)
maroon = (128, 0, 0,255)
mediumaquamarine = (102, 205, 170,255)
mediumblue = (0, 0, 205,255)
mediumorchid = (186, 85, 211,255)
mediumpurple = (147, 112, 219,255)
mediumseagreen = (60, 179, 113,255)
mediumslateblue = (123, 104, 238,255)
mediumspringgreen = (0, 250, 154,255)
mediumturquoise = (72, 209, 204,255)
mediumvioletred = (199, 21, 133,255)
midnightblue = (25, 25, 112,255)
mintcream = (245, 255, 250,255)
mistyrose = (255, 228, 225,255)
moccasin = (255, 228, 181,255)
navajowhite = (255, 222, 173,255)
navy = (0, 0, 128,255)
oldlace = (253, 245, 230,255)
olive = (128, 128, 0,255)
olivedrab = (107, 142, 35,255)
orange = (255, 165, 0,255)
orangered = (255, 69, 0,255)
orchid = (218, 112, 214,255)
palegoldenrod = (238, 232, 170,255)
palegreen = (152, 251, 152,255)
paleturquoise = (175, 238, 238,255)
palevioletred = (219, 112, 147,255)
papayawhip = (255, 239, 213,255)
peachpuff = (255, 218, 185,255)
peru = (205, 133, 63,255)
pink = (255, 192, 203,255)
plum = (221, 160, 221,255)
powderblue = (176, 224, 230,255)
purple = (128, 0, 128,255)
red = (255, 0, 0,255)
rosybrown = (188, 143, 143,255)
royalblue = (65, 105, 225,255)
saddlebrown = (139, 69, 19,255)
salmon = (250, 128, 114,255)
sandybrown = (244, 164, 96,255)
seagreen = (46, 139, 87,255)
seashell = (255, 245, 238,255)
sienna = (160, 82, 45,255)
silver = (192, 192, 192,255)
skyblue = (135, 206, 235,255)
slateblue = (106, 90, 205,255)
slategray = (112, 128, 144,255)
slategrey = (112, 128, 144,255)
snow = (255, 250, 250,255)
springgreen = (0, 255, 127,255)
steelblue = (70, 130, 180,255)
tan = (210, 180, 140,255)
teal = (0, 128, 128,255)
thistle = (216, 191, 216,255)
tomato = (255, 99, 71,255)
turquoise = (64, 224, 208,255)
violet = (238, 130, 238,255)
wheat = (245, 222, 179,255)
white = (255, 255, 255,255)
whitesmoke = (245, 245, 245,255)
yellow = (255, 255, 0,255)
yellowgreen = (154, 205, 50,255)



 _newfile_ :Z:\DESKTOP\CODING\seize/src/dic.py



from pyglet.window import key

ù = 824633720832
char_little2 = 953482739712
char_chapo = 949187772416

low_dic = {key.SPACE : ' ',key.EXCLAMATION : '!'
                ,key.DOLLAR : '$' ,ù : 'ù'
                ,key.PARENRIGHT : ')',key.ASTERISK : '*',char_little2:'²'
                ,key.COMMA : ','

                ,key.TAB : '   '

                ,key._0 : 'à',key._1 : '&',key._2 : 'é',key._3 : '\"',key._4 : '\'',key._5 : '(',key._6 : '-',key._7 : 'è',key._8 : '_',key._9 : 'ç'

                ,key.COLON : ':',key.SEMICOLON : ';',key.LESS : '<',key.EQUAL : '='

                ,key.A : 'a',key.B : 'b',key.C : 'c',key.D : 'd',key.E : 'e',key.F : 'f',key.G : 'g',key.H : 'h',key.I : 'i'
                ,key.J : 'j',key.K : 'k',key.L : 'l',key.M : 'm',key.N : 'n',key.O : 'o',key.P : 'p',key.Q : 'q',key.R : 'r',key.S : 's'
                ,key.T : 't',key.U : 'u',key.V : 'v',key.W : 'w',key.X : 'x',key.Y : 'y',key.Z : 'z'

                ,key.NUM_0 : '0',key.NUM_1 : '1',key.NUM_2 : '2',key.NUM_3 : '3',key.NUM_4 : '4',key.NUM_5 : '5',key.NUM_6 : '6'
                ,key.NUM_7 : '7',key.NUM_8 : '8',key.NUM_9 : '9',
                }

up_dic = {key.SPACE : ' ',key.EXCLAMATION : '§'
                ,key.DOLLAR : '£' ,ù : '%'
                ,key.PARENRIGHT : '°',key.ASTERISK : 'µ'
                ,key.COMMA : '?'

                ,key.TAB : '   '

                ,key._0 : '0',key._1 : '1',key._2 : '2',key._3 : '3',key._4 : '4',key._5 : '5',key._6 : '6',key._7 : '7',key._8 : '8',key._9 : '9'

                ,key.COLON : '/',key.SEMICOLON : '.',key.LESS : '>',key.EQUAL : '+'

                ,key.A : 'A',key.B : 'B',key.C : 'C',key.D : 'D',key.E : 'E',key.F : 'F',key.G : 'G',key.H : 'H',key.I : 'I'
                ,key.J : 'J',key.K : 'K',key.L : 'L',key.M : 'M',key.N : 'N',key.O : 'O',key.P : 'P',key.Q : 'Q',key.R : 'R',key.S : 'S'
                ,key.T : 'T',key.U : 'U',key.V : 'V',key.W : 'W',key.X : 'X',key.Y : 'Y',key.Z : 'Z'

                ,key.NUM_0 : '0',key.NUM_1 : '1',key.NUM_2 : '2',key.NUM_3 : '3',key.NUM_4 : '4',key.NUM_5 : '5',key.NUM_6 : '6'
                ,key.NUM_7 : '7',key.NUM_8 : '8',key.NUM_9 : '9',
                }

modif_dic = {key.BACKSPACE : 'back'
            ,key.RETURN : 'enter'
            ,key.ENTER : 'enter'
            ,key.DELETE : 'delete'}

motion_dic ={key.LEFT : 'left'
            ,key.UP : 'up'
            ,key.RIGHT : 'right'
            ,key.DOWN : 'down'


            ,key.END : 'end'

            ,key.HOME : 'home'
            ,key.PAGEUP : 'pageup'
            ,key.PAGEDOWN : 'pagedown'
            ,key.BEGIN : 'begin'
            }



 _newfile_ :Z:\DESKTOP\CODING\seize/src/graphic.py




from src.utils import *
import src.colors as c
import pyglet



### LABELS

class MyLabel(pyglet.text.Label):


    def __init__(self,text='', font_name=None, font_size=None, bold=False, italic=False, \
                    color=(255, 255, 255, 255), x=0, y=0, width=None, height=None, \
                    anchor_x='left', anchor_y='baseline', align='left', multiline=False, dpi=None, batch=None, group=None):

        super(MyLabel,self).__init__(text=text,font_name=font_name, font_size=font_size, bold=bold, italic=italic, \
                        color=color, x=x, y=y, width=width, height=height, \
                        anchor_x=anchor_x, anchor_y=anchor_y, align=align, multiline=multiline, dpi=dpi, batch=batch, group=group)

    def get_end(self,cursor):
        if cursor == 'end':
            cursor = len(self.text)
        return self.text[cursor:]

    def get_width(self,cursor):

        if cursor == 'end':
            if self.text == '':
                return 0
            return self.content_width
        elif cursor <= -len(self.text):
            return 0
        else:
            old = self.text
            self.del_end(cursor)
            w = self.content_width
            self.text = old
            return w

    def del_end(self,cursor):
        if cursor == 'end':
            cursor = len(self.text)
        self.text = self.text[:cursor]

    def change(self,cursor,char):

        text = self.text

        if cursor == 'end':
            cursor = len(text)

        self.text = text[:cursor] + char + text[cursor:]

    def modif(self,cursor,key):

        text = self.text

        if cursor == 'end':
            cursor = len(text)

        if key == 'back':
            if cursor != 0:
                self.text = text[:cursor-1] + text[cursor:]

    def get_xy(self):
        return self.x,self.y

### SEIZE

class Seize():

    # init

    def __init__(self,name,id, x=0, y=0, batch=None, group=None,initial=''):

        self.name = name
        self.cursor = [0,"end"]

        self.id = id

        self.x = x
        self.y = y
        self.padding = 10

        self.batch = batch
        self.group = group

        self.font_name={'normal':'arial','title':'arial','subtitle':'arial'}
        self.font_size={'normal':16,'title':32,'subtitle':24}

        self.cont = []
        self.summary = []

        if initial == '':
            self.cont = [MyLabel(font_name=self.font_name['normal'],font_size=self.font_size['normal'],color=(255,255,255,255), x=x, y=y, batch=self.batch, group=self.group)]
            self.summary = ['normal']
        else:
            self.load_text(initial)

        #self.comment = [...]

    # main fonctions

    def motion(self,motion):

        if motion == 'right':
            if self.cursor[1] == -1:
                self.cursor[1] = 'end'
            elif self.cursor[1] != 'end':
                self.cursor[1]+=1
            else:
                final_line = self.cursor[0] != len(self.cont)-1
                self.motion('down')
                if final_line:
                    self.motion('begin')

        elif motion == 'left':
            endup = False
            if self.cursor[1] == 'end':
                if len(self.cont[self.cursor[0]].text) != 0:
                    self.cursor[1] = -1
                else:
                    endup = True
            elif self.cursor[1] != -len(self.cont[self.cursor[0]].text):
                self.cursor[1]-=1
            else:
                endup = True

            if endup:
                first_line = self.cursor[0] != 0
                self.motion('up')
                if first_line:
                    self.motion('end')

        elif motion == 'up':
            self.cursor[0] -= 1
            if self.cursor[0] < 0:
                self.cursor[0] = 0
            else:
                cur = self.convert_cursor_end_to_beg(self.cursor[0]+1,self.cursor[1])
                self.cursor[1] = self.convert_cursor_beg_to_end(self.cursor[0],cur)
                if self.cursor[1] >= 0:
                    self.cursor[1] = 'end'

                """if self.cursor[1] < -len(self.cont[self.cursor[0]].text):
                    self.motion('begin')"""

        elif motion == 'down':

            self.cursor[0] += 1
            if self.cursor[0] >= len(self.cont):
                self.cursor[0] = len(self.cont) -1
            else:
                cur = self.convert_cursor_end_to_beg(self.cursor[0]-1,self.cursor[1])
                self.cursor[1] = self.convert_cursor_beg_to_end(self.cursor[0],cur)
                if self.cursor[1] >= 0:
                    self.cursor[1] = 'end'
                """if self.cursor[1] < -len(self.cont[self.cursor[0]].text):
                    self.motion('begin')"""

        elif motion == 'begin':
            self.cursor[1]=-len(self.cont[self.cursor[0]].text)
            if self.cursor[1] == 0:
                self.cursor[1] = 'end'

        elif motion == 'end':
            self.cursor[1] = 'end'

    def modif(self,key):

        if key in ['back']:
            if self.convert_cursor_end_to_beg(*self.cursor) > 0:
                self.cont[self.cursor[0]].modif(self.cursor[1],key)
            elif self.cursor[0] != 0:
                if self.len_seize() == 0 :
                    self.cont[self.cursor[0]].delete()
                    self.cont = self.cont[:self.cursor[0]] + self.cont[self.cursor[0]+1:]
                    self.cursor = [self.cursor[0]-1,'end']
                else:
                    self.change(self.cont[self.cursor[0]].text,(self.cursor[0]-1,'end'))
                    self.cont[self.cursor[0]].delete()
                    self.cont = self.cont[:self.cursor[0]] + self.cont[self.cursor[0]+1:]
                    self.cursor[0]-=1

        elif key == 'enter':

            newtext = self.cont[self.cursor[0]].get_end(self.cursor[1])
            self.cont[self.cursor[0]].del_end(self.cursor[1])

            self.add_Lab(self.cursor[0]+1,newtext)
            self.motion('down')
            self.motion('begin')

        elif key == 'delete':
            if self.cursor != [len(self.cont)-1,'end']:
                self.motion('right')
                self.modif('back')

    def change(self,char,cur=None):
        if cur == None:
            self.cont[self.cursor[0]].change(self.cursor[1],char)
        else:
            self.cont[cur[0]].change(cur[1],char)

    # one time fonctions

    def load_text(self,text=''):

        text = text.split('\n')
        for i in range(len(text)):
            self.load_line(text[i],i)

    def load_line(self,line='',cursor=0):

        ## là on mettra les séparations pour mettre en gras, italique, etc..
        self.add_Lab(cursor,line)

    def add_Lab(self,cursor,text='',style='normal'):

        y = self.y
        for i in range(cursor):
            y = y - self.font_size[self.summary[i]] - self.padding

        labs = self.cont
        self.cont = labs[:cursor] + [MyLabel(text=text,font_name=self.font_name[style],font_size=self.font_size[style], \
                            color=(255,255,255,255), x=self.x, y=y, batch=self.batch, group=self.group)] + labs[cursor:]

        self.summary = self.summary[:cursor] + [style] + self.summary[cursor:]

        for i in range(cursor+1,len(self.cont)):
            self.cont[i].y = self.cont[i].y - self.font_size[style] - self.padding

    def move(self,pos):
        self.x,self.y = pos
        self.refresh()

    def movedx(self,vec):
        self.x,self.y = self.x+vec[0],self.y+vec[1]
        self.refresh()

    def adapt_xy(self,oldS,S):
        self.x *= S[0]/oldS[0]
        self.y *= S[1]/oldS[1]


    # refresh

    def hide(self,hide=True):

        for lab in self.cont:
            if hide and (lab.color[3] != 0):
                lab.color = [*lab.color[:3],0]
            elif (not hide)  and (lab.color[3] == 0):
                lab.color = [*lab.color[:3],255]


    def refresh(self,anchor=(0,0)):

        y = self.y + anchor[1]
        #print(self.x,self.y)

        for i in range(len(self.cont)):
            self.cont[i].y = y
            self.cont[i].x = self.x + anchor[0]
            y = y - self.font_size[self.summary[i]] - self.padding

    # getters

    def convert_cursor_end_to_beg(self,line,cur):
        if cur == 'end':
            cur = 0
        return len(self.cont[line].text) + cur

    def convert_cursor_beg_to_end(self,line,cur):
        if cur == 'end':
            cur = 0
        return -len(self.cont[line].text) + cur

    def len_seize(self):
        return len(self.cont[self.cursor[0]].text)

    def get_text(self):

        full_text = ''
        for lab in self.cont:
            full_text += lab.text+'\n'
        #print(full_text)
        return full_text

    # byebye functions

    def delete(self):
        for lab in self.cont:
            lab.delete()


### CURSOR

class Cursor(pyglet.sprite.Sprite):

    def __init__(self,x=0,y=0,group=None,batch=None):

        tman = TextureManager()
        text = tman.add_Texture(1,1)

        super(Cursor,self).__init__(text,x,y,batch=batch,group=group)

        self.cmd = pyglet.text.Label('',font_name='arial',font_size=16,group=group, \
                        batch=batch,color=(255,255,255,255),anchor_y='top')

    def refresh(self,seize,S,anchor=(0,0)):

        self.cmd_refresh(seize,S)
        self.update(scale_x=2,scale_y=seize.font_size[seize.summary[seize.cursor[0]]])

        y = seize.y + anchor[1]
        #print(seize.x,seize.y)

        for i in range(seize.cursor[0]):
            y = y - seize.font_size[seize.summary[i]] - seize.padding
        self.y = y

        self.x = seize.x + anchor[0] + seize.cont[seize.cursor[0]].get_width(seize.cursor[1])

    def cmd_refresh(self,seize,S):

        self.cmd.x,self.cmd.y = 20,S[1] -60
        self.cmd.text = 'cursor '+str(seize.name)+' : '+str(seize.cursor)


### SPRITES, FILTERS, ...

class TextureManager():

    def __init__(self):

        self.textures = []

    def add_Texture(self,w,h,color=(255,255,255,255)):

        pattern = pyglet.image.SolidColorImagePattern(color)
        return pattern.create_image(w,h)

class SpriteManager():

    def __init__(self,batch=None):

        self.sprites = []
        self.batch= batch

    def add_Spr(self,text,x,y,group=None):

        return pyglet.sprite.Sprite(text,x,y,batch=self.batch,group=group)

tman = TextureManager()
#sman = SpriteManager()

### BUTTONS ...

class Button():

    def __init__(self,box,function,color=(255,255,255,0),hover=(255,255,255,50),batch=None,group=None):

        if type(box) == type(()):
            self.box = box(box)
        else:
            self.box = box

        self.function = function
        self.hover = False
        self.visible = True

        self.col = color
        self.col_hover = hover

        self.img = tman.add_Texture(*box.wh,color)
        self.img_hover = tman.add_Texture(*box.wh,hover)
        self.img_pressed = tman.add_Texture(*box.wh,c.red)

        self.skin = pyglet.sprite.Sprite(self.img,*self.box.xy,batch=batch,group=group)

    def iamhere(self):

        if not self.hover:
            self.hover = True
            self.skin.image = self.img_hover

    def nothere(self):

        if self.hover:
            self.hover = False
            self.skin.image = self.img

    def ipressed(self):
        self.skin.image = self.img_pressed

    def irealeased(self):
        self.skin.image = self.img
        self.function()

    def update(self,x,y):

        if x != self.skin.x:
            self.skin.x = x
            self.box.x = x
        if y != self.skin.y:
            self.skin.y = y
            self.box.y = y

    ## oeoe

    def _set_xy(self,pos):
        self.skin.x,self.skin.y = pos

    def _xy(self):
        return self.skin.x,self.skin.y

    def _h(self):
        return self.box.h

    def _w(self):
        return self.box.w

    xy = property(_xy,_set_xy)
    h = property(_h)
    w = property(_w)

    def _xywh(self):
        return self.box.xywh

    xywh = property(_xywh)

class ButtonBar():

    def __init__(self,xy,S,buttons,style="w",padding = 20,sec_padding=10,align="right",color=c.air,batch=None,group=None,groupbutt=None):

        self.xy = xy # in percent
        self.butt = buttons
        self.padd = padding
        self.sec_padd = sec_padding
        self.align = align
        self.col = color

        self.visible = True

        self.batch = batch
        self.groupbutt = groupbutt

        self.img = tman.add_Texture(1,1,color)
        x,y = self.xy[0]*S[0],self.xy[1]*S[1]
        self.skin = pyglet.sprite.Sprite(self.img,x,y,batch=batch,group=group)

        self.style = style
        if self.style == "w":
            self.wh = S[0],0
        else:
            self.wh = 0,S[1]

        self.check_butt_size()

        self.update(S)

    def check_butt_size(self):

        if self.style == "w":
            for butt in self.butt:
                if butt.h > self.wh[1]:
                    self.wh = self.wh[0],butt.h
        else:
            for butt in self.butt:
                if butt.w > self.wh[0]:
                    self.wh = self.w,butt.wh[1]

    def get_hovers(self):

        hovers = []
        for butt in self.butt:
            if butt.hover:
                return [butt]
        return hovers

    def update(self,S):

        #self.check_butt_size()

        if self.xy[0]*S[0] != self.skin.x:
            self.skin.x = self.xy[0]*S[0]
        if self.xy[1]*S[1] != self.skin.y:
            self.skin.y = self.xy[1]*S[1]

        if self.style == "w":
            self.skin.update(scale_x=S[0],scale_y=self.wh[1]+2*self.sec_padd)
            y = self.xy[1]*S[1]+self.sec_padd
            if self.align == "right":
                x = S[0] - self.padd - self.butt[0].w
                dx = -1
            else:
                x = self.padd
                dx = 1

            for butt in self.butt:
                butt.update(x,y)
                x += dx*(butt.w+self.padd)
        else:
            self.skin.update(scale_x=self.wh[0]+2*self.sec_padd,scale_y=S[1])
            x = self.xy[0]*S[0]+self.sec_padd
            if self.align == "top":
                y = S[1] - self.padd - self.butt[0].h
                dy = -1
            else:
                y = self.padd
                dy = 1

            for butt in self.butt:
                butt.update(x,y)
                y += dy*(butt.h+self.padd)

    def check_mouse(self,x,y):

        #get boxes
        boxes = []
        ids = []
        for i in range(len(self.butt)):
            if self.butt[i].visible:
                boxes.append(self.butt[i].xywh)
                ids += [i]

        #check colli
        good_box = colli_ABP_mult(boxes,(x,y))
        for butt in self.butt:
            butt.nothere()
        if good_box != None:
            self.butt[ids[good_box]].iamhere()

    def check_pressed(self):
        a = self.get_hovers()
        if a != []:
            a[0].ipressed()

    def check_released(self):
        a = self.get_hovers()
        if a != []:
            a[0].irealeased()


def colli_ABP_mult(boxes,pt):
    ## retourne None si le point est dans aucune boite
    ## retourne l'indice de la premiere box des boites concernées sinon
    #
    #   pt : (x,y)
    #   boxes : [box1,box2...,boxn]
    #   boxi : (x,y,w,h)
    #


    goodx = []
    goody = []

    ## Premier niveau -> on vérifie si on est pas à gauche de toutes les box
    for i in range(len(boxes)):
        if pt[0] >= boxes[i][0]:
            goodx.append(i)
    if goodx == []:
        return None # retourne un ouai bah t'es dans rien mon pote

    ## 2e niveau -> on vérifie si on est pas en dessous des box qui sont bien
    for i in goodx:
        if pt[1] >= boxes[i][1]:
            goody.append(i)
    if goody == []:
        return None # retourne un ouai bah t'es dans rien mon pote

    ## 3e niveau -> on vérifie si on est pas à droite des box qui sont bien
    goodx = []
    for i in goody:
        if pt[0] < boxes[i][0] + boxes[i][2]:
            goodx.append(i)
    if goodx == []:
        return None # retourne un ouai bah t'es dans rien mon pote

    ## 4e niveau -> on vérifie si on est pas en haut des box qui sont bien
    goody = []
    for i in goodx:
        if pt[1] < boxes[i][1] + boxes[i][3]:
            goody.append(i)
    if goody == []:
        return None # retourne un ouai bah t'es dans rien mon pote

    return goody[0]



 _newfile_ :Z:\DESKTOP\CODING\seize/src/utils.py






import random,os,ctypes,time
from ctypes import windll, Structure, c_long, byref
from math import *
#from win32gui import GetWindowRect, GetForegroundWindow, GetWindowText


class POINT(Structure):
    _fields_ = [("x", c_long), ("y", c_long)]

class box():

    def __init__(self,x,y,w,h):

        self.w = w
        self.h = h
        self.x = x
        self.y = y

    def _wh(self):
        return self.w,self.h

    def _xy(self):
        return self.x,self.y

    def _xywh(self):
        return self.x,self.y,self.w,self.h

    wh = property(_wh)
    xy = property(_xy)
    xywh = property(_xywh)

## partie SCREEN

def get_screen_size():
    user32 = ctypes.windll.user32
    return user32.GetSystemMetrics(0), user32.GetSystemMetrics(1)


## partie random

def choice(thg):

    if type(thg) == type({}):
        return choice(list(thg.keys()))
        #print(thg.keys())
    else:
        return random.choice(thg)

def randmultint(n,a,b=None): #returns n differents numbers between a and b-1

    if b == None:
        return randmultint(n,0,a-1)
    else:
        t = []
        while len(t) < n:
            new = random.randint(a,b-1)
            while new in t:
                new = random.randint(a,b-1)
            t.append(new)
        return t


def get_key_from_value(d,v,s=[]): # v valeur seule, d dic ou tab

    if type(d) == type({}):
        for key,val in d.items():
            if type(val) != type({}) and type(val) != type([]):
                if v == val:
                    return s+[key]
            else:
                ns = get_key_from_value(val,v,s+[key])
                if ns != None:
                    return ns

    elif type(d) == type([]):
        for key in range(len(d)):
            val = d[key]
            if type(val) != type({}) and type(val) != type([]):
                #print(val)
                if v == val:
                    return s+[key]
            else:
                ns = get_key_from_value(val,v,s+[key])
                if ns != None:
                    return ns

    return None

def getMousePos():
    pt = POINT()
    windll.user32.GetCursorPos(byref(pt))
    return pt.x,pt.y

def module(x,y):
    return sqrt(x**2+y**2)

def int_rd(dec):
    if dec < int(dec)+0.5:
        return int(dec)
    else:
        return ceil(dec)

def sign(n):
    if n==0:
        return 0
    else:
        return n//abs(n)

def rangef(a,b,d=1):

    res = []
    if b > a:
        while b>a:
            res.append(a)
            a+=d
    else:
        while abs(b-a)>0:
            res.append(a)
            a+=d

    return res

ids = 1112

def get_id(key):

    global ids

    id = ''+key
    id+=str(ids)
    ids+=1
    return id

def mycopy(thg):

    if type(thg) == type([]):

        res = []

        for i in thg:
            res.append(mycopy(i))

        return res

    else:

        return thg

def truncate(f, n=3):
    '''Truncates/pads a float f to n decimal places without rounding'''
    s = '{}'.format(f)
    if 'e' in s or 'E' in s:
        return '{0:.{1}f}'.format(f, n)
    i, p, d = s.partition('.')
    return '.'.join([i, (d+'0'*n)[:n]])

### PARTIE AUTO-SAUVEGARDE

def save_code(bigpath,path = ['/.','/src'],save_path = '/autosav/'):

    autosav = ''

    for chem in path:
        #print('path',bigpath+chem,':',os.listdir(bigpath+chem))
        try:
            for file in os.listdir(bigpath+chem):
                if file[-3:] == '.py':
                    autosav += '\n\n\n _newfile_ :' + bigpath+chem+'/'+file + '\n\n\n'
                    with open(bigpath+chem+'/'+file,'r') as f:
                        autosav += f.read()
        except :
            jsghd=0
            #print('no path',bigpath+chem,':',os.listdir(bigpath+chem))

    version = ['alpha',10001]

    try:
        with open(bigpath+save_path+'version','r') as f:
            tab = f.read().split('_')
            version = [tab[0],int(tab[1])*10000+int(tab[2])]
        version[1]+=1
        with open(bigpath+save_path+'version','w') as f:
            f.write(version[0]+'_'+str(version[1])[0]+'_'+str(version[1])[-4:])
    except:
        os.makedirs(bigpath+save_path)
        with open(bigpath+save_path+'version','w') as f:
            f.write(version[0]+'_'+str(version[1])[0]+'_'+str(version[1])[-4:])

    with open(bigpath+save_path+'saved_'+version[0]+'_'+str(version[1])[0]+'_'+str(version[1])[-4:]+'.savd','w') as f:
        f.write(autosav)

    print('files saved, version',version[0]+'_'+str(version[1])[0]+'_'+str(version[1])[-4:])

def recup_files(path2):

    currentpath = path2.split('\\')[-1]
    currentpath = currentpath.split('/')[-1]
    currentpath = path2[:(len(path2)-len(currentpath))]

    all =[]
    with open(path2,'r') as f:
        all = f.readlines()

    files = {}
    titles = [0]
    file = []
    for line in all:
        if '_newfile_ :' in line and line[-4:] == '.py\n':
            name = line[len('_newfile_ '):]
            names = name.split('\\')
            names2 = []

            for nam in names:
                for naam in nam.split('/'):
                    names2.append(naam)
                    name = ('/').join(names2[-2:])

            files[titles[-1]] = file
            titles.append(name[:-1])
            file = []
        else:
            file.append(line)

    files[titles[-1]] = file

    for name in files:
        print(name)
        if name != 0:
            try:
                with open(currentpath+name,'w') as f:
                    for line in files[name]:
                        f.write(line)
            except :
                file = name.split('/')[0]
                os.makedirs(currentpath+file)
                with open(currentpath+name,'w') as f:
                    for line in files[name]:
                        f.write(line)

def get_version(bigpath,save_path = '/autosav/'):
    version = ['alpha',10001]

    try:
        with open(bigpath+save_path+'version','r') as f:
            tab = f.read().split('_')
            version = [tab[0],int(tab[1])*10000+int(tab[2])]
    except:
        a=0
    return version[0]+'_'+str(version[1])[0]+'_'+str(version[1])[-4:]

def compt(bigpath,path = ['/.','/src']):

    long = 0

    for chem in path:
        try:
            for file in os.listdir(bigpath+chem):
                if file[-3:] == '.py':
                    with open(bigpath+chem+'/'+file,'r') as f:
                        long += len(f.readlines())
        except :
            jsghd=0
            #print('no path',bigpath+chem,':',os.listdir(bigpath+chem))

    return long
